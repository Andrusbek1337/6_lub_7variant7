# Лабороторная работа по дисциплине "Язык программирования C++"

# ЛАБОРАТОРНАЯ РАБОТА №6 КОЛЛЕКЦИИ И НАСЛЕДОВАНИЕ

# Вариант: 7

# Группа: ИТ-5-2024

# ФИО: Шалашов Андрей юрьевич

# Описание лабораторной работы:

В задании 1 необходимо описать класс, который реализует функционал неупорядоченного списка
(обратиться к элементу по индексу нельзя), который может содержать только уникальные элементы
(в случае добавления повторяющихся значений ошибки нет, такой элемент просто не добавляется).
Полем класса является массив. В классе должны присутствовать методы добавления и удаления
элементов, а также методы:
• Union() — объединяет две коллекции;
• Except() — позволяет удалить из первой коллекции элементы второй;
• Intersect() — получает коллекцию, состоящую из элементов, общих для двух коллекций;
• Contains() — проверяет на наличие элемента, возвращает bool.
С помощью данного класса необходимо решить задачу своего варианта.


В задании 2 необходимо описать класс, который реализует функционал словаря (запрещается
использовать готовые решения) и решить задачу своего варианта. В классе должны присутствовать
методы добавления и удаления элементов, учесть, что ключи должны быть уникальными. Исходные
данные содержаться в текстовом файле.
Классы из заданий 1 и2 должны работать при любом типе данных

## Задание 1.

Название класса: HashSet

##### Поля:
    std::vector<T> elements_ - вектор для хранения уникальных элементов

##### Методы:
    Add(const T& item) - добавление элемента (если он уникален)
    Remove(const T& item) - удаление элемента
    Union(const HashSet<T>& other) - объединение двух коллекций
    Except(const HashSet<T>& other) - разность коллекций (элементы из this, которых нет в other)
    Intersect(const HashSet<T>& other) - пересечение коллекций
    Contains(const T& item) - проверка наличия элемента
    Size() - получение размера коллекции
    GetElements() - получение всех элементов
    Clear() - очистка коллекции
    findIndex_(const T& item) (private) - поиск индекса элемента


##### Алгоритм решения:
    Сбор данных:
      Вводится количество сладкоежек n
      Для каждого сладкоежки создается два объекта HashSet<string>:
      likedChocolates[i] - любимые виды шоколада
      dislikedChocolates[i] - нелюбимые виды шоколада
      Автоматически собирается множество всех упомянутых видов шоколада

    Анализ предпочтений:
      Нравится всем:
      Берем пересечение (Intersect) всех списков любимых шоколадов
      Исключаем (Except) те, что кто-то не любит
      Нравится некоторым:
      Собираем все шоколады, которые кто-то любит
      Исключаем те, что нравятся всем
      Не нравится никому:
      Находим пересечение всех списков нелюбимых шоколадов

    Вывод результатов:
      Выводим три категории с соответствующими видами шоколада


#### Тестирование:
<img width="663" height="847" alt="image" src="https://github.com/user-attachments/assets/df257dd1-266f-4628-927f-776e28b42071" />
<img width="677" height="886" alt="image" src="https://github.com/user-attachments/assets/0b449748-8a9e-4876-8aa0-29c6c9b86cd8" />
<img width="668" height="884" alt="image" src="https://github.com/user-attachments/assets/be5aa072-9d0c-4e2c-a5f0-9a6328984360" />
<img width="619" height="106" alt="image" src="https://github.com/user-attachments/assets/7838eda0-f910-4ba6-8662-aeb02e0fe994" />
<img width="644" height="129" alt="image" src="https://github.com/user-attachments/assets/aad701d7-4cb5-40e9-ada3-961f5f65f0e9" />
<img width="798" height="123" alt="image" src="https://github.com/user-attachments/assets/f2a8ee47-7651-465a-856f-accae8f36049" />

## Задание 2.

Название класса: Dictionary

##### Поля:
    std::vector<KeyValuePair> items_ - вектор для хранения пар ключ-значение
    struct KeyValuePair (private) - структура для хранения пары ключ-значение

##### Методы:
    Add(const K& key, const V& value) - добавление или обновление элемента
    Remove(const K& key) - удаление элемента по ключу
    ContainsKey(const K& key) - проверка наличия ключа
    TryGetValue(const K& key, V& value) - получение значения по ключу
    Count() - получение количества элементов
    Clear() - очистка словаря
    Keys() - получение всех ключей
    findIndexByKey_(const K& key) (private) - поиск индекса по ключу


##### Алгоритм решения:
    Чтение данных из файла:
      Читаем файл data.txt по пути C:\Users\a987o\Desktop\c++\6lub_c+++\data.txt
      Первая строка содержит количество магазинов N
      Каждая следующая строка: <Фирма> <Улица> <Жирность> <Цена>

    Обработка данных:
      Создаем два объекта Dictionary<int, int>:
      minPrices - жирность → минимальная цена
      minPriceCount - жирность → количество магазинов с минимальной ценой
      Для каждой записи:
      Проверяем корректность данных (жирность 15/20/25, цена 20-500)
      Если цена меньше текущей минимальной для данной жирности:
      Обновляем minPrices
      Устанавливаем счетчик в 1
      Если цена равна текущей минимальной:
      Увеличиваем счетчик в minPriceCount
      Если это первая цена для данной жирности:
      Добавляем запись в оба словаря

    Формирование результата:
      Для каждой жирности (15, 20, 25):
      Получаем количество магазинов с минимальной ценой из minPriceCount
      Если запись отсутствует, результат = 0

    Вывод результата:
      Выводим три числа через пробел в формате: [для 15%] [для 20%] [для 25%]


#### тестирование:
<img width="635" height="94" alt="image" src="https://github.com/user-attachments/assets/6a41c1c3-7bd7-4262-b4f5-718624db026a" />
